module Logic
  module V503
    Signatures = {
      functions: [{ source: 'Closure *luaF_newCclosure (lua_State *L, int nelems);',
                    ffi: [:luaF_newCclosure, %i[pointer int], :pointer] },
                  { source: 'Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e);',
                    ffi: [:luaF_newLclosure, %i[pointer int pointer], :pointer] },
                  { source: 'LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B);',
                    ffi: [:luaL_prepbuffer, [:pointer], :pointer] },
                  { source: 'LUALIB_API const char *luaL_checklstring (lua_State *L, int numArg, size_t *l);',
                    ffi: [:luaL_checklstring, %i[pointer int pointer], :pointer] },
                  { source: 'LUALIB_API const char *luaL_optlstring (lua_State *L, int numArg, const char *def, size_t *l);',
                    ffi: [:luaL_optlstring, %i[pointer int pointer pointer], :pointer] },
                  { source: 'LUALIB_API int luaL_argerror (lua_State *L, int numarg, const char *extramsg);',
                    ffi: [:luaL_argerror, %i[pointer int pointer], :int] },
                  { source: 'LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *e);',
                    ffi: [:luaL_callmeta, %i[pointer int pointer], :int] },
                  { source: 'LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...);',
                    ffi: [:luaL_error, %i[pointer pointer varargs], :int] },
                  { source: 'LUALIB_API int luaL_findstring (const char *st, const char *const lst[]);',
                    ffi: [:luaL_findstring, %i[pointer pointer], :int] },
                  { source: 'LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *e);',
                    ffi: [:luaL_getmetafield, %i[pointer int pointer], :int] },
                  { source: 'LUALIB_API int luaL_getn (lua_State *L, int t);',
                    ffi: [:luaL_getn, %i[pointer int], :int] },
                  { source: 'LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz, const char *name);',
                    ffi: [:luaL_loadbuffer, %i[pointer pointer ulong pointer], :int] },
                  { source: 'LUALIB_API int luaL_loadfile (lua_State *L, const char *filename);',
                    ffi: [:luaL_loadfile, %i[pointer pointer], :int] },
                  { source: 'LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname);',
                    ffi: [:luaL_newmetatable, %i[pointer pointer], :int] },
                  { source: 'LUALIB_API int luaL_ref (lua_State *L, int t);',
                    ffi: [:luaL_ref, %i[pointer int], :int] },
                  { source: 'LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname);',
                    ffi: [:luaL_typerror, %i[pointer int pointer], :int] },
                  { source: 'LUALIB_API int lua_dobuffer (lua_State *L, const char *buff, size_t sz, const char *n);',
                    ffi: [:lua_dobuffer, %i[pointer pointer ulong pointer], :int] },
                  { source: 'LUALIB_API int lua_dofile (lua_State *L, const char *filename);',
                    ffi: [:lua_dofile, %i[pointer pointer], :int] },
                  { source: 'LUALIB_API int lua_dostring (lua_State *L, const char *str);',
                    ffi: [:lua_dostring, %i[pointer pointer], :int] },
                  { source: 'LUALIB_API int luaopen_base (lua_State *L);',
                    ffi: [:luaopen_base, [:pointer], :int] },
                  { source: 'LUALIB_API int luaopen_debug (lua_State *L);',
                    ffi: [:luaopen_debug, [:pointer], :int] },
                  { source: 'LUALIB_API int luaopen_io (lua_State *L);',
                    ffi: [:luaopen_io, [:pointer], :int] },
                  { source: 'LUALIB_API int luaopen_loadlib (lua_State *L);',
                    ffi: [:luaopen_loadlib, [:pointer], :int] },
                  { source: 'LUALIB_API int luaopen_math (lua_State *L);',
                    ffi: [:luaopen_math, [:pointer], :int] },
                  { source: 'LUALIB_API int luaopen_string (lua_State *L);',
                    ffi: [:luaopen_string, [:pointer], :int] },
                  { source: 'LUALIB_API int luaopen_table (lua_State *L);',
                    ffi: [:luaopen_table, [:pointer], :int] },
                  { source: 'LUALIB_API lua_Number luaL_checknumber (lua_State *L, int numArg);',
                    ffi: [:luaL_checknumber, %i[pointer int], :double] },
                  { source: 'LUALIB_API lua_Number luaL_optnumber (lua_State *L, int nArg, lua_Number def);',
                    ffi: [:luaL_optnumber, %i[pointer int double], :double] },
                  { source: 'LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname);',
                    ffi: [:luaL_checkudata, %i[pointer int pointer], :pointer] },
                  { source: 'LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);',
                    ffi: [:luaL_addlstring, %i[pointer pointer ulong], :void] },
                  { source: 'LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s);',
                    ffi: [:luaL_addstring, %i[pointer pointer], :void] },
                  { source: 'LUALIB_API void luaL_addvalue (luaL_Buffer *B);',
                    ffi: [:luaL_addvalue, [:pointer], :void] },
                  { source: 'LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B);',
                    ffi: [:luaL_buffinit, %i[pointer pointer], :void] },
                  { source: 'LUALIB_API void luaL_checkany (lua_State *L, int narg);',
                    ffi: [:luaL_checkany, %i[pointer int], :void] },
                  { source: 'LUALIB_API void luaL_checkstack (lua_State *L, int sz, const char *msg);',
                    ffi: [:luaL_checkstack, %i[pointer int pointer], :void] },
                  { source: 'LUALIB_API void luaL_checktype (lua_State *L, int narg, int t);',
                    ffi: [:luaL_checktype, %i[pointer int int], :void] },
                  { source: 'LUALIB_API void luaL_getmetatable (lua_State *L, const char *tname);',
                    ffi: [:luaL_getmetatable, %i[pointer pointer], :void] },
                  { source: 'LUALIB_API void luaL_openlib (lua_State *L, const char *libname, const luaL_reg *l, int nup);',
                    ffi: [:luaL_openlib, %i[pointer pointer pointer int], :void] },
                  { source: 'LUALIB_API void luaL_pushresult (luaL_Buffer *B);',
                    ffi: [:luaL_pushresult, [:pointer], :void] },
                  { source: 'LUALIB_API void luaL_setn (lua_State *L, int t, int n);',
                    ffi: [:luaL_setn, %i[pointer int int], :void] },
                  { source: 'LUALIB_API void luaL_unref (lua_State *L, int t, int ref);',
                    ffi: [:luaL_unref, %i[pointer int int], :void] },
                  { source: 'LUALIB_API void luaL_where (lua_State *L, int lvl);',
                    ffi: [:luaL_where, %i[pointer int], :void] },
                  { source: 'LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);',
                    ffi: [:lua_getlocal, %i[pointer pointer int], :pointer] },
                  { source: 'LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);',
                    ffi: [:lua_getupvalue, %i[pointer int int], :pointer] },
                  { source: 'LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...);',
                    ffi: [:lua_pushfstring, %i[pointer pointer varargs], :pointer] },
                  { source: 'LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt, va_list argp);',
                    ffi: [:lua_pushvfstring, %i[pointer pointer varargs], :pointer] },
                  { source: 'LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);',
                    ffi: [:lua_setlocal, %i[pointer pointer int], :pointer] },
                  { source: 'LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);',
                    ffi: [:lua_setupvalue, %i[pointer int int], :pointer] },
                  { source: 'LUA_API const char *lua_tostring (lua_State *L, int idx);',
                    ffi: [:lua_tostring, %i[pointer int], :pointer] },
                  { source: 'LUA_API const char *lua_typename (lua_State *L, int tp);',
                    ffi: [:lua_typename, %i[pointer int], :pointer] },
                  { source: 'LUA_API const char *lua_version (void);',
                    ffi: [:lua_version, [], :pointer] },
                  { source: 'LUA_API const void *lua_topointer (lua_State *L, int idx);',
                    ffi: [:lua_topointer, %i[pointer int], :pointer] },
                  { source: 'LUA_API int lua_checkstack (lua_State *L, int sz);',
                    ffi: [:lua_checkstack, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);',
                    ffi: [:lua_cpcall, %i[pointer int pointer], :int] },
                  { source: 'LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data);',
                    ffi: [:lua_dump, %i[pointer int pointer], :int] },
                  { source: 'LUA_API int lua_equal (lua_State *L, int idx1, int idx2);',
                    ffi: [:lua_equal, %i[pointer int int], :int] },
                  { source: 'LUA_API int lua_error (lua_State *L);',
                    ffi: [:lua_error, [:pointer], :int] },
                  { source: 'LUA_API int lua_getgccount (lua_State *L);',
                    ffi: [:lua_getgccount, [:pointer], :int] },
                  { source: 'LUA_API int lua_getgcthreshold (lua_State *L);',
                    ffi: [:lua_getgcthreshold, [:pointer], :int] },
                  { source: 'LUA_API int lua_gethookcount (lua_State *L);',
                    ffi: [:lua_gethookcount, [:pointer], :int] },
                  { source: 'LUA_API int lua_gethookmask (lua_State *L);',
                    ffi: [:lua_gethookmask, [:pointer], :int] },
                  { source: 'LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);',
                    ffi: [:lua_getinfo, %i[pointer pointer pointer], :int] },
                  { source: 'LUA_API int lua_getmetatable (lua_State *L, int objindex);',
                    ffi: [:lua_getmetatable, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);',
                    ffi: [:lua_getstack, %i[pointer int pointer], :int] },
                  { source: 'LUA_API int lua_gettop (lua_State *L);',
                    ffi: [:lua_gettop, [:pointer], :int] },
                  { source: 'LUA_API int lua_iscfunction (lua_State *L, int idx);',
                    ffi: [:lua_iscfunction, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_isnumber (lua_State *L, int idx);',
                    ffi: [:lua_isnumber, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_isstring (lua_State *L, int idx);',
                    ffi: [:lua_isstring, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_isuserdata (lua_State *L, int idx);',
                    ffi: [:lua_isuserdata, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_lessthan (lua_State *L, int idx1, int idx2);',
                    ffi: [:lua_lessthan, %i[pointer int int], :int] },
                  { source: 'LUA_API int lua_load (lua_State *L, lua_Chunkreader reader, void *dt, const char *chunkname);',
                    ffi: [:lua_load, %i[pointer char pointer pointer], :int] },
                  { source: 'LUA_API int lua_next (lua_State *L, int idx);',
                    ffi: [:lua_next, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);',
                    ffi: [:lua_pcall, %i[pointer int int int], :int] },
                  { source: 'LUA_API int lua_pushupvalues (lua_State *L);',
                    ffi: [:lua_pushupvalues, [:pointer], :int] },
                  { source: 'LUA_API int lua_rawequal (lua_State *L, int idx1, int idx2);',
                    ffi: [:lua_rawequal, %i[pointer int int], :int] },
                  { source: 'LUA_API int lua_resume (lua_State *L, int narg);',
                    ffi: [:lua_resume, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_setfenv (lua_State *L, int idx);',
                    ffi: [:lua_setfenv, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);',
                    ffi: [:lua_sethook, %i[pointer void int int], :int] },
                  { source: 'LUA_API int lua_setmetatable (lua_State *L, int objindex);',
                    ffi: [:lua_setmetatable, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_toboolean (lua_State *L, int idx);',
                    ffi: [:lua_toboolean, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_type (lua_State *L, int idx);',
                    ffi: [:lua_type, %i[pointer int], :int] },
                  { source: 'LUA_API int lua_yield (lua_State *L, int nresults);',
                    ffi: [:lua_yield, %i[pointer int], :int] },
                  { source: 'LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);',
                    ffi: [:lua_atpanic, %i[pointer int], :int] },
                  { source: 'LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx);',
                    ffi: [:lua_tocfunction, %i[pointer int], :int] },
                  { source: 'LUA_API lua_Hook lua_gethook (lua_State *L);',
                    ffi: [:lua_gethook, [:pointer], :void] },
                  { source: 'LUA_API lua_Number lua_tonumber (lua_State *L, int idx);',
                    ffi: [:lua_tonumber, %i[pointer int], :double] },
                  { source: 'LUA_API lua_State *lua_newthread (lua_State *L);',
                    ffi: [:lua_newthread, [:pointer], :pointer] },
                  { source: 'LUA_API lua_State *lua_open (void);',
                    ffi: [:lua_open, [], :pointer] },
                  { source: 'LUA_API lua_State *lua_tothread (lua_State *L, int idx);',
                    ffi: [:lua_tothread, %i[pointer int], :pointer] },
                  { source: 'LUA_API size_t lua_strlen (lua_State *L, int idx);',
                    ffi: [:lua_strlen, %i[pointer int], :ulong] },
                  { source: 'LUA_API void *lua_newuserdata (lua_State *L, size_t sz);',
                    ffi: [:lua_newuserdata, %i[pointer ulong], :pointer] },
                  { source: 'LUA_API void *lua_touserdata (lua_State *L, int idx);',
                    ffi: [:lua_touserdata, %i[pointer int], :pointer] },
                  { source: 'LUA_API void lua_call (lua_State *L, int nargs, int nresults);',
                    ffi: [:lua_call, %i[pointer int int], :void] },
                  { source: 'LUA_API void lua_close (lua_State *L);',
                    ffi: [:lua_close, [:pointer], :void] },
                  { source: 'LUA_API void lua_concat (lua_State *L, int n);',
                    ffi: [:lua_concat, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_getfenv (lua_State *L, int idx);',
                    ffi: [:lua_getfenv, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_gettable (lua_State *L, int idx);',
                    ffi: [:lua_gettable, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_insert (lua_State *L, int idx);',
                    ffi: [:lua_insert, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_newtable (lua_State *L);',
                    ffi: [:lua_newtable, [:pointer], :void] },
                  { source: 'LUA_API void lua_pushboolean (lua_State *L, int b);',
                    ffi: [:lua_pushboolean, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);',
                    ffi: [:lua_pushcclosure, %i[pointer int int], :void] },
                  { source: 'LUA_API void lua_pushlightuserdata (lua_State *L, void *p);',
                    ffi: [:lua_pushlightuserdata, %i[pointer pointer], :void] },
                  { source: 'LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t l);',
                    ffi: [:lua_pushlstring, %i[pointer pointer ulong], :void] },
                  { source: 'LUA_API void lua_pushnil (lua_State *L);',
                    ffi: [:lua_pushnil, [:pointer], :void] },
                  { source: 'LUA_API void lua_pushnumber (lua_State *L, lua_Number n);',
                    ffi: [:lua_pushnumber, %i[pointer double], :void] },
                  { source: 'LUA_API void lua_pushstring (lua_State *L, const char *s);',
                    ffi: [:lua_pushstring, %i[pointer pointer], :void] },
                  { source: 'LUA_API void lua_pushvalue (lua_State *L, int idx);',
                    ffi: [:lua_pushvalue, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_rawget (lua_State *L, int idx);',
                    ffi: [:lua_rawget, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_rawgeti (lua_State *L, int idx, int n);',
                    ffi: [:lua_rawgeti, %i[pointer int int], :void] },
                  { source: 'LUA_API void lua_rawset (lua_State *L, int idx);',
                    ffi: [:lua_rawset, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_rawseti (lua_State *L, int idx, int n);',
                    ffi: [:lua_rawseti, %i[pointer int int], :void] },
                  { source: 'LUA_API void lua_remove (lua_State *L, int idx);',
                    ffi: [:lua_remove, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_replace (lua_State *L, int idx);',
                    ffi: [:lua_replace, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_setgcthreshold (lua_State *L, int newthreshold);',
                    ffi: [:lua_setgcthreshold, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_settable (lua_State *L, int idx);',
                    ffi: [:lua_settable, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_settop (lua_State *L, int idx);',
                    ffi: [:lua_settop, %i[pointer int], :void] },
                  { source: 'LUA_API void lua_xmove (lua_State *from, lua_State *to, int n);',
                    ffi: [:lua_xmove, %i[pointer pointer int], :void] },
                  { source: 'Node *luaH_mainposition (const Table *t, const TObject *key);',
                    ffi: [:luaH_mainposition, %i[pointer pointer], :pointer] },
                  { source: 'Proto *luaF_newproto (lua_State *L);',
                    ffi: [:luaF_newproto, [:pointer], :pointer] },
                  { source: 'Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff);',
                    ffi: [:luaY_parser, %i[pointer pointer pointer], :pointer] },
                  { source: 'Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff);',
                    ffi: [:luaU_undump, %i[pointer pointer pointer], :pointer] },
                  { source: 'StkId luaD_precall (lua_State *L, StkId func);',
                    ffi: [:luaD_precall, %i[pointer int], :int] },
                  { source: 'StkId luaV_execute (lua_State *L);',
                    ffi: [:luaV_execute, [:pointer], :int] },
                  { source: 'TObject *luaH_set (lua_State *L, Table *t, const TObject *key);',
                    ffi: [:luaH_set, %i[pointer pointer pointer], :pointer] },
                  { source: 'TObject *luaH_setnum (lua_State *L, Table *t, int key);',
                    ffi: [:luaH_setnum, %i[pointer pointer int], :pointer] },
                  { source: 'TString *luaS_newlstr (lua_State *L, const char *str, size_t l);',
                    ffi: [:luaS_newlstr, %i[pointer pointer ulong], :pointer] },
                  { source: 'Table *luaH_new (lua_State *L, int narray, int lnhash);',
                    ffi: [:luaH_new, %i[pointer int int], :pointer] },
                  { source: 'Udata *luaS_newudata (lua_State *L, size_t s);',
                    ffi: [:luaS_newudata, %i[pointer ulong], :pointer] },
                  { source: 'UpVal *luaF_findupval (lua_State *L, StkId level);',
                    ffi: [:luaF_findupval, %i[pointer int], :pointer] },
                  { source: 'char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);',
                    ffi: [:luaZ_openspace, %i[pointer pointer ulong], :pointer] },
                  { source: 'const TObject *luaH_get (Table *t, const TObject *key);',
                    ffi: [:luaH_get, %i[pointer pointer], :pointer] },
                  { source: 'const TObject *luaH_getnum (Table *t, int key);',
                    ffi: [:luaH_getnum, %i[pointer int], :pointer] },
                  { source: 'const TObject *luaH_getstr (Table *t, TString *key);',
                    ffi: [:luaH_getstr, %i[pointer pointer], :pointer] },
                  { source: 'const TObject *luaT_gettm (Table *events, TMS event, TString *ename);',
                    ffi: [:luaT_gettm, %i[pointer int pointer], :pointer] },
                  { source: 'const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event);',
                    ffi: [:luaT_gettmbyobj, %i[pointer pointer int], :pointer] },
                  { source: 'const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key, int loop);',
                    ffi: [:luaV_gettable, %i[pointer pointer pointer int], :pointer] },
                  { source: 'const TObject *luaV_tonumber (const TObject *obj, TObject *n);',
                    ffi: [:luaV_tonumber, %i[pointer pointer], :pointer] },
                  { source: 'const char *luaF_getlocalname (const Proto *func, int local_number, int pc);',
                    ffi: [:luaF_getlocalname, %i[pointer int int], :pointer] },
                  { source: 'const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);',
                    ffi: [:luaO_pushfstring, %i[pointer pointer varargs], :pointer] },
                  { source: 'const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp);',
                    ffi: [:luaO_pushvfstring, %i[pointer pointer varargs], :pointer] },
                  { source: 'const char *luaX_token2str (LexState *ls, int token);',
                    ffi: [:luaX_token2str, %i[pointer int], :pointer] },
                  { source: 'int luaD_pcall (lua_State *L, Pfunc func, void *u, ptrdiff_t oldtop, ptrdiff_t ef);',
                    ffi: [:luaD_pcall, %i[pointer void pointer int int], :int] },
                  { source: 'int luaD_protectedparser (lua_State *L, ZIO *z, int bin);',
                    ffi: [:luaD_protectedparser, %i[pointer pointer int], :int] },
                  { source: 'int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);',
                    ffi: [:luaD_rawrunprotected, %i[pointer void pointer], :int] },
                  { source: 'int luaG_checkcode (const Proto *pt);',
                    ffi: [:luaG_checkcode, [:pointer], :int] },
                  { source: 'int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2);',
                    ffi: [:luaG_ordererror, %i[pointer pointer pointer], :int] },
                  { source: 'int luaH_next (lua_State *L, Table *t, StkId key);',
                    ffi: [:luaH_next, %i[pointer pointer int], :int] },
                  { source: 'int luaK_code (FuncState *fs, Instruction i, int line);',
                    ffi: [:luaK_code, %i[pointer long int], :int] },
                  { source: 'int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);',
                    ffi: [:luaK_codeABC, %i[pointer int int int int], :int] },
                  { source: 'int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);',
                    ffi: [:luaK_codeABx, %i[pointer int int int], :int] },
                  { source: 'int luaK_exp2RK (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_exp2RK, %i[pointer pointer], :int] },
                  { source: 'int luaK_exp2anyreg (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_exp2anyreg, %i[pointer pointer], :int] },
                  { source: 'int luaK_getlabel (FuncState *fs);',
                    ffi: [:luaK_getlabel, [:pointer], :int] },
                  { source: 'int luaK_jump (FuncState *fs);',
                    ffi: [:luaK_jump, [:pointer], :int] },
                  { source: 'int luaK_numberK (FuncState *fs, lua_Number r);',
                    ffi: [:luaK_numberK, %i[pointer double], :int] },
                  { source: 'int luaK_stringK (FuncState *fs, TString *s);',
                    ffi: [:luaK_stringK, %i[pointer pointer], :int] },
                  { source: 'int luaO_int2fb (unsigned int x);',
                    ffi: [:luaO_int2fb, [:int], :int] },
                  { source: 'int luaO_log2 (unsigned int x);',
                    ffi: [:luaO_log2, [:int], :int] },
                  { source: 'int luaO_rawequalObj (const TObject *t1, const TObject *t2);',
                    ffi: [:luaO_rawequalObj, %i[pointer pointer], :int] },
                  { source: 'int luaO_str2d (const char *s, lua_Number *result);',
                    ffi: [:luaO_str2d, %i[pointer pointer], :int] },
                  { source: 'int luaU_endianness (void);',
                    ffi: [:luaU_endianness, [], :int] },
                  { source: 'int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2);',
                    ffi: [:luaV_equalval, %i[pointer pointer pointer], :int] },
                  { source: 'int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r);',
                    ffi: [:luaV_lessthan, %i[pointer pointer pointer], :int] },
                  { source: 'int luaV_tostring (lua_State *L, StkId obj);',
                    ffi: [:luaV_tostring, %i[pointer int], :int] },
                  { source: 'int luaX_lex (LexState *LS, SemInfo *seminfo);',
                    ffi: [:luaX_lex, %i[pointer pointer], :int] },
                  { source: 'int luaZ_fill (ZIO *z);', ffi: [:luaZ_fill, [:pointer], :int] },
                  { source: 'int luaZ_lookahead (ZIO *z);',
                    ffi: [:luaZ_lookahead, [:pointer], :int] },
                  { source: 'lua_State *luaE_newthread (lua_State *L);',
                    ffi: [:luaE_newthread, [:pointer], :pointer] },
                  { source: 'size_t luaC_separateudata (lua_State *L);',
                    ffi: [:luaC_separateudata, [:pointer], :ulong] },
                  { source: 'size_t luaZ_read (ZIO* z, void* b, size_t n);',
                    ffi: [:luaZ_read, %i[pointer pointer ulong], :ulong] },
                  { source: 'void *luaM_growaux (lua_State *L, void *block, int *size, int size_elem, int limit, const char *errormsg);',
                    ffi: [:luaM_growaux,
                          %i[pointer pointer pointer int int pointer],
                          :pointer] },
                  { source: 'void *luaM_realloc (lua_State *L, void *oldblock, lu_mem oldsize, lu_mem size);',
                    ffi: [:luaM_realloc, %i[pointer pointer long long], :pointer] },
                  { source: 'void luaA_pushobject (lua_State *L, const TObject *o);',
                    ffi: [:luaA_pushobject, %i[pointer pointer], :void] },
                  { source: 'void luaC_callGCTM (lua_State *L);',
                    ffi: [:luaC_callGCTM, [:pointer], :void] },
                  { source: 'void luaC_collectgarbage (lua_State *L);',
                    ffi: [:luaC_collectgarbage, [:pointer], :void] },
                  { source: 'void luaC_link (lua_State *L, GCObject *o, lu_byte tt);',
                    ffi: [:luaC_link, %i[pointer pointer char], :void] },
                  { source: 'void luaC_sweep (lua_State *L, int all);',
                    ffi: [:luaC_sweep, %i[pointer int], :void] },
                  { source: 'void luaD_call (lua_State *L, StkId func, int nResults);',
                    ffi: [:luaD_call, %i[pointer int int], :void] },
                  { source: 'void luaD_callhook (lua_State *L, int event, int line);',
                    ffi: [:luaD_callhook, %i[pointer int int], :void] },
                  { source: 'void luaD_growstack (lua_State *L, int n);',
                    ffi: [:luaD_growstack, %i[pointer int], :void] },
                  { source: 'void luaD_poscall (lua_State *L, int wanted, StkId firstResult);',
                    ffi: [:luaD_poscall, %i[pointer int int], :void] },
                  { source: 'void luaD_reallocCI (lua_State *L, int newsize);',
                    ffi: [:luaD_reallocCI, %i[pointer int], :void] },
                  { source: 'void luaD_reallocstack (lua_State *L, int newsize);',
                    ffi: [:luaD_reallocstack, %i[pointer int], :void] },
                  { source: 'void luaD_throw (lua_State *L, int errcode);',
                    ffi: [:luaD_throw, %i[pointer int], :void] },
                  { source: 'void luaE_freethread (lua_State *L, lua_State *L1);',
                    ffi: [:luaE_freethread, %i[pointer pointer], :void] },
                  { source: 'void luaF_close (lua_State *L, StkId level);',
                    ffi: [:luaF_close, %i[pointer int], :void] },
                  { source: 'void luaF_freeclosure (lua_State *L, Closure *c);',
                    ffi: [:luaF_freeclosure, %i[pointer pointer], :void] },
                  { source: 'void luaF_freeproto (lua_State *L, Proto *f);',
                    ffi: [:luaF_freeproto, %i[pointer pointer], :void] },
                  { source: 'void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2);',
                    ffi: [:luaG_aritherror, %i[pointer pointer pointer], :void] },
                  { source: 'void luaG_concaterror (lua_State *L, StkId p1, StkId p2);',
                    ffi: [:luaG_concaterror, %i[pointer int int], :void] },
                  { source: 'void luaG_errormsg (lua_State *L);',
                    ffi: [:luaG_errormsg, [:pointer], :void] },
                  { source: 'void luaG_inithooks (lua_State *L);',
                    ffi: [:luaG_inithooks, [:pointer], :void] },
                  { source: 'void luaG_runerror (lua_State *L, const char *fmt, ...);',
                    ffi: [:luaG_runerror, %i[pointer pointer varargs], :void] },
                  { source: 'void luaG_typeerror (lua_State *L, const TObject *o, const char *opname);',
                    ffi: [:luaG_typeerror, %i[pointer pointer pointer], :void] },
                  { source: 'void luaH_free (lua_State *L, Table *t);',
                    ffi: [:luaH_free, %i[pointer pointer], :void] },
                  { source: 'void luaK_checkstack (FuncState *fs, int n);',
                    ffi: [:luaK_checkstack, %i[pointer int], :void] },
                  { source: 'void luaK_concat (FuncState *fs, int *l1, int l2);',
                    ffi: [:luaK_concat, %i[pointer pointer int], :void] },
                  { source: 'void luaK_dischargevars (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_dischargevars, %i[pointer pointer], :void] },
                  { source: 'void luaK_exp2nextreg (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_exp2nextreg, %i[pointer pointer], :void] },
                  { source: 'void luaK_exp2val (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_exp2val, %i[pointer pointer], :void] },
                  { source: 'void luaK_fixline (FuncState *fs, int line);',
                    ffi: [:luaK_fixline, %i[pointer int], :void] },
                  { source: 'void luaK_goiffalse (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_goiffalse, %i[pointer pointer], :void] },
                  { source: 'void luaK_goiftrue (FuncState *fs, expdesc *e);',
                    ffi: [:luaK_goiftrue, %i[pointer pointer], :void] },
                  { source: 'void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);',
                    ffi: [:luaK_indexed, %i[pointer pointer pointer], :void] },
                  { source: 'void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);',
                    ffi: [:luaK_infix, %i[pointer int pointer], :void] },
                  { source: 'void luaK_nil (FuncState *fs, int from, int n);',
                    ffi: [:luaK_nil, %i[pointer int int], :void] },
                  { source: 'void luaK_patchlist (FuncState *fs, int list, int target);',
                    ffi: [:luaK_patchlist, %i[pointer int int], :void] },
                  { source: 'void luaK_patchtohere (FuncState *fs, int list);',
                    ffi: [:luaK_patchtohere, %i[pointer int], :void] },
                  { source: 'void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);',
                    ffi: [:luaK_posfix, %i[pointer int pointer pointer], :void] },
                  { source: 'void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);',
                    ffi: [:luaK_prefix, %i[pointer int pointer], :void] },
                  { source: 'void luaK_reserveregs (FuncState *fs, int n);',
                    ffi: [:luaK_reserveregs, %i[pointer int], :void] },
                  { source: 'void luaK_self (FuncState *fs, expdesc *e, expdesc *key);',
                    ffi: [:luaK_self, %i[pointer pointer pointer], :void] },
                  { source: 'void luaK_setcallreturns (FuncState *fs, expdesc *var, int nresults);',
                    ffi: [:luaK_setcallreturns, %i[pointer pointer int], :void] },
                  { source: 'void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);',
                    ffi: [:luaK_storevar, %i[pointer pointer pointer], :void] },
                  { source: 'void luaO_chunkid (char *out, const char *source, int len);',
                    ffi: [:luaO_chunkid, %i[pointer pointer int], :void] },
                  { source: 'void luaS_freeall (lua_State *L);',
                    ffi: [:luaS_freeall, [:pointer], :void] },
                  { source: 'void luaS_resize (lua_State *L, int newsize);',
                    ffi: [:luaS_resize, %i[pointer int], :void] },
                  { source: 'void luaT_init (lua_State *L);',
                    ffi: [:luaT_init, [:pointer], :void] },
                  { source: 'void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data);',
                    ffi: [:luaU_dump, %i[pointer pointer int pointer], :void] },
                  { source: 'void luaV_concat (lua_State *L, int total, int last);',
                    ffi: [:luaV_concat, %i[pointer int int], :void] },
                  { source: 'void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val);',
                    ffi: [:luaV_settable, %i[pointer pointer pointer int], :void] },
                  { source: 'void luaX_checklimit (LexState *ls, int val, int limit, const char *msg);',
                    ffi: [:luaX_checklimit, %i[pointer int int pointer], :void] },
                  { source: 'void luaX_errorline (LexState *ls, const char *s, const char *token, int line);',
                    ffi: [:luaX_errorline, %i[pointer pointer pointer int], :void] },
                  { source: 'void luaX_init (lua_State *L);',
                    ffi: [:luaX_init, [:pointer], :void] },
                  { source: 'void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source);',
                    ffi: [:luaX_setinput, %i[pointer pointer pointer pointer], :void] },
                  { source: 'void luaX_syntaxerror (LexState *ls, const char *s);',
                    ffi: [:luaX_syntaxerror, %i[pointer pointer], :void] },
                  { source: 'void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name);',
                    ffi: [:luaZ_init, %i[pointer char pointer pointer], :void] }],
      macros: [{ source: '#define luaK_codeAsBx(fs,o,A,sBx) luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)',
                 name: 'luaK_codeAsBx',
                 input: %w[fs o A sBx] },
               { source: '#define luaL_addsize(B,n) ((B)->p += (n))',
                 name: 'luaL_addsize',
                 input: %w[B n] },
               { source: '#define luaL_checkint(L,n) ((int)luaL_checknumber(L, n))',
                 name: 'luaL_checkint',
                 input: %w[L n] },
               { source: '#define luaL_checklong(L,n) ((long)luaL_checknumber(L, n))',
                 name: 'luaL_checklong',
                 input: %w[L n] },
               { source: '#define luaL_checkstring(L,n) (luaL_checklstring(L, (n), NULL))',
                 name: 'luaL_checkstring',
                 input: %w[L n] },
               { source: '#define luaL_optint(L,n,d) ((int)luaL_optnumber(L, n,(lua_Number)(d)))',
                 name: 'luaL_optint',
                 input: %w[L n d] },
               { source: '#define luaL_optlong(L,n,d) ((long)luaL_optnumber(L, n,(lua_Number)(d)))',
                 name: 'luaL_optlong',
                 input: %w[L n d] },
               { source: '#define luaL_optstring(L,n,d) (luaL_optlstring(L, (n), (d), NULL))',
                 name: 'luaL_optstring',
                 input: %w[L n d] },
               { source: '#define luaM_free(L, b, s) luaM_realloc(L, (b), (s), 0)',
                 name: 'luaM_free',
                 input: %w[L b s] },
               { source: '#define luaM_freearray(L, b, n, t) luaM_realloc(L, (b), \\ cast(lu_mem, n)*cast(lu_mem, sizeof(t)), 0)',
                 name: 'luaM_freearray',
                 input: %w[L b n t] },
               { source: '#define luaM_freelem(L, b) luaM_realloc(L, (b), sizeof(*(b)), 0)',
                 name: 'luaM_freelem',
                 input: %w[L b] },
               { source: '#define luaM_malloc(L, t) luaM_realloc(L, NULL, 0, (t))',
                 name: 'luaM_malloc',
                 input: %w[L t] },
               { source: '#define luaM_new(L, t) cast(t *, luaM_malloc(L, sizeof(t)))',
                 name: 'luaM_new',
                 input: %w[L t] },
               { source: '#define luaM_newvector(L, n,t) cast(t *, luaM_malloc(L, \\ cast(lu_mem, n)*cast(lu_mem, sizeof(t))))',
                 name: 'luaM_newvector',
                 input: %w[L n t] },
               { source: '#define luaS_new(L, s) (luaS_newlstr(L, s, strlen(s)))',
                 name: 'luaS_new',
                 input: %w[L s] },
               { source: '#define luaS_newliteral(L, s) (luaS_newlstr(L, "" s, \\ (sizeof(s)/sizeof(char))-1))',
                 name: 'luaS_newliteral',
                 input: %w[L s] },
               { source: '#define luaZ_freebuffer(L, buff) luaZ_resizebuffer(L, buff, 0)',
                 name: 'luaZ_freebuffer',
                 input: %w[L buff] },
               { source: '#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)',
                 name: 'luaZ_initbuffer',
                 input: %w[L buff] },
               { source: '#define lua_assert(c) assert(c)',
                 name: 'lua_assert',
                 input: ['c'] },
               { source: '#define lua_getref(L,ref) lua_rawgeti(L, LUA_REGISTRYINDEX, ref)',
                 name: 'lua_getref',
                 input: %w[L ref] },
               { source: '#define lua_getregistry(L) lua_pushvalue(L, LUA_REGISTRYINDEX)',
                 name: 'lua_getregistry',
                 input: ['L'] },
               { source: '#define lua_isboolean(L,n) (lua_type(L,n) == LUA_TBOOLEAN)',
                 name: 'lua_isboolean',
                 input: %w[L n] },
               { source: '#define lua_isfunction(L,n) (lua_type(L,n) == LUA_TFUNCTION)',
                 name: 'lua_isfunction',
                 input: %w[L n] },
               { source: '#define lua_islightuserdata(L,n) (lua_type(L,n) == LUA_TLIGHTUSERDATA)',
                 name: 'lua_islightuserdata',
                 input: %w[L n] },
               { source: '#define lua_isnil(L,n) (lua_type(L,n) == LUA_TNIL)',
                 name: 'lua_isnil',
                 input: %w[L n] },
               { source: '#define lua_isnone(L,n) (lua_type(L,n) == LUA_TNONE)',
                 name: 'lua_isnone',
                 input: %w[L n] },
               { source: '#define lua_isnoneornil(L, n) (lua_type(L,n) <= 0)',
                 name: 'lua_isnoneornil',
                 input: %w[L n] },
               { source: '#define lua_istable(L,n) (lua_type(L,n) == LUA_TTABLE)',
                 name: 'lua_istable',
                 input: %w[L n] },
               { source: '#define lua_lock(l) lua_assert((*getlock(l))++ == 0)',
                 name: 'lua_lock',
                 input: ['l'] },
               { source: '#define lua_number2int(i,d) __asm__("fldl %1\\nfistpl %0":"=m"(i):"m"(d))',
                 name: 'lua_number2int',
                 input: %w[i d] },
               { source: '#define lua_pop(L,n) lua_settop(L, -(n)-1)',
                 name: 'lua_pop',
                 input: %w[L n] },
               { source: '#define lua_pushcfunction(L,f) lua_pushcclosure(L, f, 0)',
                 name: 'lua_pushcfunction',
                 input: %w[L f] },
               { source: '#define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \\ (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))',
                 name: 'lua_ref',
                 input: %w[L lock] },
               { source: '#define lua_str2number(s,p) strtol((s), (p), 10)',
                 name: 'lua_str2number',
                 input: %w[s p] },
               { source: '#define lua_unboxpointer(L,i) (*(void **)(lua_touserdata(L, i)))',
                 name: 'lua_unboxpointer',
                 input: %w[L i] },
               { source: '#define lua_unlock(l) lua_assert(--(*getlock(l)) == 0)',
                 name: 'lua_unlock',
                 input: ['l'] },
               { source: '#define lua_unref(L,ref) luaL_unref(L, LUA_REGISTRYINDEX, (ref))',
                 name: 'lua_unref',
                 input: %w[L ref] },
               { source: '#define lua_userstateopen(l) if (l != NULL) getlock(l) = &islocked;',
                 name: 'lua_userstateopen',
                 input: ['l'] }]
    }
  end
end
